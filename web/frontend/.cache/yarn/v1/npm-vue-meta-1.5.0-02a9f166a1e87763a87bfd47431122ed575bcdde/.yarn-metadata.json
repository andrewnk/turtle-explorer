{
  "manifest": {
    "name": "vue-meta",
    "description": "manage page meta info in Vue 2.0 server-rendered apps",
    "version": "1.5.0",
    "author": {
      "name": "Declan de Wet",
      "email": "declandewet@me.com"
    },
    "bugs": {
      "url": "https://github.com/declandewet/vue-meta/issues"
    },
    "scripts": {
      "build": "rollup -c",
      "codecov": "codecov",
      "deploy": "npm version",
      "dev": "babel-node examples/server.js",
      "lint": "standard --verbose | snazzy",
      "minify": "uglifyjs lib/vue-meta.js -cm --comments -o lib/vue-meta.min.js",
      "postbuild": "npm run minify",
      "postdeploy": "git push origin master --follow-tags && npm run release",
      "postversion": "npm run update-cdn && git add . && git commit -m \":ship: CDN update\"",
      "prebuild": "rimraf lib",
      "predeploy": "git checkout master && git pull -r",
      "prerelease": "npm run build",
      "pretest": "npm run lint",
      "preversion": "npm run toc",
      "release": "npm publish",
      "test": "cross-env NODE_ENV=test karma start karma.conf.js",
      "toc": "doctoc README.md --title '# Table of Contents'",
      "update-cdn": "babel-node scripts/update-cdn.js"
    },
    "dependencies": {
      "deepmerge": "^2.0.0",
      "lodash.isplainobject": "^4.0.6",
      "object-assign": "^4.1.1"
    },
    "devDependencies": {
      "babel-cli": "^6.24.1",
      "babel-core": "^6.25.0",
      "babel-loader": "^7.1.1",
      "babel-plugin-istanbul": "^4.1.4",
      "babel-preset-env": "^1.6.1",
      "babel-register": "^6.24.1",
      "chai": "^4.1.1",
      "codecov": "^3.0.0",
      "cross-env": "^5.0.5",
      "css-loader": "^0.28.4",
      "doctoc": "^1.3.0",
      "es6-promise": "^4.1.1",
      "express": "^4.15.4",
      "express-urlrewrite": "^1.2.0",
      "file-loader": "^1.0.0-rc.0",
      "json-loader": "^0.5.7",
      "karma": "^2.0.0",
      "karma-chai": "^0.1.0",
      "karma-coverage": "^1.1.1",
      "karma-mocha": "^1.3.0",
      "karma-mocha-reporter": "^2.2.3",
      "karma-phantomjs-launcher": "^1.0.4",
      "karma-sourcemap-loader": "^0.3.7",
      "karma-webpack": "^2.0.4",
      "mocha": "^5.0.0",
      "phantomjs-prebuilt": "^2.1.15",
      "rimraf": "^2.6.1",
      "rollup": "^0.47.4",
      "rollup-plugin-buble": "^0.18.0",
      "rollup-plugin-commonjs": "^8.1.0",
      "rollup-plugin-json": "^2.3.0",
      "rollup-plugin-node-resolve": "^3.0.0",
      "snazzy": "^7.0.0",
      "standard": "^10.0.3",
      "uglify-js": "^3.0.27",
      "update-section": "^0.3.3",
      "vue": "^2.4.2",
      "vue-loader": "^14.0.0",
      "vue-router": "^3.0.0",
      "vue-server-renderer": "^2.4.2",
      "vue-template-compiler": "^2.4.2",
      "vuex": "^3.0.0",
      "webpack": "^3.5.4",
      "webpack-dev-server": "^2.7.1"
    },
    "files": [
      "lib",
      "yarn.lock",
      "types/index.d.ts",
      "types/vue.d.ts"
    ],
    "homepage": "https://github.com/declandewet/vue-meta",
    "keywords": [
      "attribute",
      "google",
      "head",
      "helmet",
      "info",
      "meta",
      "seo",
      "server",
      "ssr",
      "title",
      "universal",
      "vue"
    ],
    "license": "MIT",
    "main": "lib/vue-meta.js",
    "typings": "types/index.d.ts",
    "nyc": {
      "exclude": [
        "test/**/*.js"
      ]
    },
    "repository": {
      "url": "git@github.com:declandewet/vue-meta.git",
      "type": "git"
    },
    "standard": {
      "globals": [
        "Vue",
        "define",
        "describe",
        "it",
        "expect",
        "before",
        "beforeEach",
        "after",
        "afterEach"
      ]
    },
    "_registry": "npm",
    "_loc": "/home/node/.cache/yarn/v1/npm-vue-meta-1.5.0-02a9f166a1e87763a87bfd47431122ed575bcdde/package.json",
    "readmeFilename": "README.md",
    "readme": "<p align=\"center\">\n  <img src=\"http://imgur.com/258WtHI.png\" alt=\"vue-meta\">\n</p>\n\n<h5 align=\"center\">\n  Manage page meta info in Vue 2.0 components. SSR + Streaming supported. Inspired by <a href=\"https://github.com/nfl/react-helmet\">react-helmet</a>.\n</h5>\n\n<p align=\"center\">\n  <a href=\"https://github.com/feross/standard\">\n    <img src=\"https://cdn.rawgit.com/feross/standard/master/badge.svg\" alt=\"Standard - JavaScript Style\">\n  </a>\n</p>\n\n<p align=\"center\">\n<a href=\"https://github.com/declandewet/vue-meta/releases/latest\"><img src=\"https://img.shields.io/github/release/declandewet/vue-meta.svg\" alt=\"github release\"></a> <a href=\"http://npmjs.org/package/vue-meta\"><img src=\"https://img.shields.io/npm/v/vue-meta.svg\" alt=\"npm version\"></a> <a href=\"https://travis-ci.org/declandewet/vue-meta\"><img src=\"https://travis-ci.org/declandewet/vue-meta.svg?branch=master\" alt=\"Build Status\"></a> <a href=\"https://codecov.io/gh/declandewet/vue-meta\"><img src=\"https://codecov.io/gh/declandewet/vue-meta/branch/master/graph/badge.svg\" alt=\"codecov\"></a><br>\n<a href=\"https://david-dm.org/declandewet/vue-meta\"><img src=\"https://david-dm.org/declandewet/vue-meta/status.svg\" alt=\"dependencies Status\"></a> <a href=\"https://david-dm.org/declandewet/vue-meta?type=dev\"><img src=\"https://david-dm.org/declandewet/vue-meta/dev-status.svg\" alt=\"devDependencies Status\"></a><br>\n<a href=\"http://npm-stat.com/charts.html?package=vue-meta\"><img src=\"https://img.shields.io/npm/dm/vue-meta.svg\" alt=\"npm downloads\"></a> <a href=\"https://gitter.im/declandewet/vue-meta\"><img src=\"https://badges.gitter.im/declandewet/vue-meta.svg\" alt=\"Gitter\"></a>\n</p>\n\n```html\n<template>\n  ...\n</template>\n\n<script>\n  export default {\n    metaInfo: {\n      title: 'My Example App', // set a title\n      titleTemplate: '%s - Yay!', // title is now \"My Example App - Yay!\"\n      htmlAttrs: {\n        lang: 'en',\n        amp: undefined // \"amp\" has no value\n      }\n    }\n  }\n</script>\n```\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n# Table of Contents\n\n- [Description](#description)\n- [Disclaimer](#disclaimer)\n- [Installation](#installation)\n    - [Yarn](#yarn)\n    - [NPM](#npm)\n    - [CDN](#cdn)\n- [Usage](#usage)\n  - [Step 1: Preparing the plugin](#step-1-preparing-the-plugin)\n      - [Options](#options)\n  - [Step 2: Server Rendering (Optional)](#step-2-server-rendering-optional)\n    - [Step 2.1: Exposing `$meta` to `bundleRenderer`](#step-21-exposing-meta-to-bundlerenderer)\n    - [Step 2.2: Populating the document meta info with `inject()`](#step-22-populating-the-document-meta-info-with-inject)\n      - [Simple Rendering with `renderToString()`](#simple-rendering-with-rendertostring)\n      - [Streaming Rendering with `renderToStream()`](#streaming-rendering-with-rendertostream)\n  - [Step 3: Start defining `metaInfo`](#step-3-start-defining-metainfo)\n    - [Recognized `metaInfo` Properties](#recognized-metainfo-properties)\n      - [`title` (String)](#title-string)\n      - [`titleTemplate` (String | Function)](#titletemplate-string--function)\n      - [`htmlAttrs` (Object)](#htmlattrs-object)\n      - [`bodyAttrs` (Object)](#bodyattrs-object)\n      - [`base` (Object)](#base-object)\n      - [`meta` ([Object])](#meta-object)\n      - [`link` ([Object])](#link-object)\n      - [`style` ([Object])](#style-object)\n      - [`script` ([Object])](#script-object)\n      - [`noscript` ([Object])](#noscript-object)\n      - [`__dangerouslyDisableSanitizers` ([String])](#__dangerouslydisablesanitizers-string)\n      - [`__dangerouslyDisableSanitizersByTagID` ({[String]})](#__dangerouslydisablesanitizersbytagid-string)\n      - [`changed` (Function)](#changed-function)\n    - [How `metaInfo` is Resolved](#how-metainfo-is-resolved)\n      - [Lists of Tags](#lists-of-tags)\n- [Performance](#performance)\n    - [How to prevent the update on the initial page render](#how-to-prevent-the-update-on-the-initial-page-render)\n- [FAQ](#faq)\n  - [How do I use component props and/or component data in `metaInfo`?](#how-do-i-use-component-props-andor-component-data-in-metainfo)\n  - [How do I populate `metaInfo` from the result of an asynchronous action?](#how-do-i-populate-metainfo-from-the-result-of-an-asynchronous-action)\n  - [Why doesn't `vue-meta` support `jsnext:main`?](#why-doesnt-vue-meta-support-jsnextmain)\n- [Examples](#examples)\n- [TypeScript Support](#typescript-support)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n\n# Description\n`vue-meta` is a [Vue 2.0](https://vuejs.org) plugin that allows you to manage your app's meta information, much like [`react-helmet`](https://github.com/nfl/react-helmet) does for React. However, instead of setting your data as props passed to a proprietary component, you simply export it as part of your component's data using the `metaInfo` property.\n\nThese properties, when set on a deeply nested component, will cleverly overwrite their parent components' `metaInfo`, thereby enabling custom info for each top-level view as well as coupling meta info directly to deeply nested subcomponents for more maintainable code.\n\n# Disclaimer\n\n**Please note** that this project is still in very early alpha development and is *not* considered to be production ready.\n**You have been warned.** There might still be a few bugs and many tests have yet to be written.\n\n# Installation\n\n### Yarn\n```sh\n$ yarn add vue-meta\n```\n\n### NPM\n```sh\n$ npm install vue-meta --save\n```\n\n### CDN\n\nUse the links below - if you want a previous version, check the instructions at https://unpkg.com.\n\n<!-- start CDN generator - do **NOT** remove this comment -->\n**Uncompressed:**\n```html\n<script src=\"https://unpkg.com/vue-meta@1.5.0/lib/vue-meta.js\"></script>\n```\n\n**Minified:**\n```html\n<script src=\"https://unpkg.com/vue-meta@1.5.0/lib/vue-meta.min.js\"></script>\n```\n<!-- end CDN generator - do **NOT** remove this comment -->\n\n# Usage\n\n## Step 1: Preparing the plugin\n> This step is optional if you don't need SSR and `Vue` is available as a global variable. `vue-meta` will install itself in this case.\n\nIn order to use this plugin, you first need to pass it to `Vue.use` - if you're not rendering on the server-side, your JS entry file will suffice. If you are rendering on the server, then place it in a file that runs both on the server and on the client before your root instance is mounted. If you're using [`vue-router`](https://github.com/vuejs/vue-router), then your main `router.js` file is a good place:\n\n**router.js:**\n```js\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport Meta from 'vue-meta'\n\nVue.use(Router)\nVue.use(Meta)\n\nexport default new Router({\n  ...\n})\n```\n\n#### Options\n\n`vue-meta` allows a few custom options:\n\n```js\nVue.use(Meta, {\n  keyName: 'metaInfo', // the component option name that vue-meta looks for meta info on.\n  attribute: 'data-vue-meta', // the attribute name vue-meta adds to the tags it observes\n  ssrAttribute: 'data-vue-meta-server-rendered', // the attribute name that lets vue-meta know that meta info has already been server-rendered\n  tagIDKeyName: 'vmid' // the property name that vue-meta uses to determine whether to overwrite or append a tag\n})\n```\n\nIf you don't care about server-side rendering, you can skip straight to [step 3](#step-3-start-defining-metainfo). Otherwise, continue. :smile:\n\n## Step 2: Server Rendering (Optional)\n\nIf you have an isomorphic/universal webapp, you'll likely want to render your metadata on the server side as well. Here's how.\n\n### Step 2.1: Exposing `$meta` to `bundleRenderer`\n\nYou'll need to expose the results of the `$meta` method that `vue-meta` adds to the Vue instance to the bundle render context before you can begin injecting your meta information. You'll need to do this in your server entry file:\n\n**server-entry.js:**\n```js\nimport app from './app'\n\nconst router = app.$router\nconst meta = app.$meta() // here\n\nexport default (context) => {\n  router.push(context.url)\n  context.meta = meta // and here\n  return app\n}\n```\n\n### Step 2.2: Populating the document meta info with `inject()`\n\nAll that's left for you to do now before you can begin using `metaInfo` options in your components is to make sure they work on the server by `inject`-ing them so you can call `text()` on each item to render out the necessary info. You have two methods at your disposal:\n\n#### Simple Rendering with `renderToString()`\n\nConsiderably the easiest method to wrap your head around is if your Vue server markup is rendered out as a string:\n\n**server.js:**\n\n```js\napp.get('*', (req, res) => {\n  const context = { url: req.url }\n  renderer.renderToString(context, (error, html) => {\n    if (error) return res.send(error.stack)\n    const bodyOpt = { body: true }\n    const {\n      title, htmlAttrs, bodyAttrs, link, style, script, noscript, meta\n    } = context.meta.inject()\n    return res.send(`\n      <!doctype html>\n      <html data-vue-meta-server-rendered ${htmlAttrs.text()}>\n        <head>\n          ${meta.text()}\n          ${title.text()}\n          ${link.text()}\n          ${style.text()}\n          ${script.text()}\n          ${noscript.text()}\n        </head>\n        <body ${bodyAttrs.text()}>\n          ${html}\n          <script src=\"/assets/vendor.bundle.js\"></script>\n          <script src=\"/assets/client.bundle.js\"></script>\n          ${script.text(bodyOpt)}\n        </body>\n      </html>\n    `)\n  })\n})\n```\n\nIf you are using a separate template file, edit your head tag with\n\n```html\n<head>\n  {{{ meta.inject().title.text() }}}\n  {{{ meta.inject().meta.text() }}}\n</head>\n```\n\nNotice the use of `{{{` to avoid double escaping. Be extremely cautious when you use `{{{` with `__dangerouslyDisableSanitizers`.\n\n#### Streaming Rendering with `renderToStream()`\n\nA little more complex, but well worth it, is to instead stream your response. `vue-meta` supports streaming with no effort (on it's part :stuck_out_tongue_winking_eye:) thanks to Vue's clever `bundleRenderer` context injection:\n\n**server.js**\n```js\napp.get('*', (req, res) => {\n  const context = { url: req.url }\n  const renderStream = renderer.renderToStream(context)\n  renderStream.once('data', () => {\n    const bodyOpt = { body: true }\n    const {\n      title, htmlAttrs, bodyAttrs, link, style, script, noscript, meta\n    } = context.meta.inject()\n    res.write(`\n      <!doctype html>\n      <html data-vue-meta-server-rendered ${htmlAttrs.text()}>\n        <head>\n          ${meta.text()}\n          ${title.text()}\n          ${link.text()}\n          ${style.text()}\n          ${script.text()}\n          ${noscript.text()}\n        </head>\n        <body ${bodyAttrs.text()}>\n    `)\n  })\n  renderStream.on('data', (chunk) => {\n    res.write(chunk)\n  })\n  renderStream.on('end', () => {\n    res.end(`\n          <script src=\"/assets/vendor.bundle.js\"></script>\n          <script src=\"/assets/client.bundle.js\"></script>\n          ${script.text(bodyOpt)}\n        </body>\n      </html>\n    `)\n  })\n  renderStream.on('error', (error) => res.status(500).end(`<pre>${error.stack}</pre>`))\n})\n```\n\n## Step 3: Start defining `metaInfo`\n\nIn any of your components, define a `metaInfo` property:\n\n**App.vue:**\n```html\n<template>\n  <div id=\"app\">\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\n  export default {\n    name: 'App',\n    metaInfo: {\n      // if no subcomponents specify a metaInfo.title, this title will be used\n      title: 'Default Title',\n      // all titles will be injected into this template\n      titleTemplate: '%s | My Awesome Webapp'\n    }\n  }\n</script>\n```\n\n**Home.vue**\n```html\n<template>\n  <div id=\"page\">\n    <h1>Home Page</h1>\n  </div>\n</template>\n\n<script>\n  export default {\n    name: 'Home',\n    metaInfo: {\n      title: 'My Awesome Webapp',\n      // override the parent template and just use the above title only\n      titleTemplate: null\n    }\n  }\n</script>\n```\n\n**About.vue**\n```html\n<template>\n  <div id=\"page\">\n    <h1>About Page</h1>\n  </div>\n</template>\n\n<script>\n  export default {\n    name: 'About',\n    metaInfo: {\n      // title will be injected into parent titleTemplate\n      title: 'About Us'\n    }\n  }\n</script>\n```\n\n### Recognized `metaInfo` Properties\n\n#### `title` (String)\n\nMaps to the inner-text value of the `<title>` element.\n\n```js\n{\n  metaInfo: {\n    title: 'Foo Bar'\n  }\n}\n```\n\n```html\n<title>Foo Bar</title>\n```\n\n#### `titleTemplate` (String | Function)\n\nThe value of `title` will be injected into the `%s` placeholder in `titleTemplate` before being rendered. The original title will be available on `metaInfo.titleChunk`.\n\n```js\n{\n  metaInfo: {\n    title: 'Foo Bar',\n    titleTemplate: '%s - Baz'\n  }\n}\n```\n\n```html\n<title>Foo Bar - Baz</title>\n```\n\nThe property can also be a function (from [v1.2.0](https://github.com/declandewet/vue-meta/releases/tag/v1.2.0)):\n\n```js\ntitleTemplate: (titleChunk) => {\n  // If undefined or blank then we don't need the hyphen\n  return titleChunk ? `${titleChunk} - Site Title` : 'Site Title';\n}\n```\n\n#### `htmlAttrs` (Object)\n\nEach **key:value** maps to the equivalent **attribute:value** of the `<html>` element.\n\n```js\n{\n  metaInfo: {\n    htmlAttrs: {\n      foo: 'bar',\n      amp: undefined\n    }\n  }\n}\n```\n\n```html\n<html foo=\"bar\" amp></html>\n```\n\n#### `bodyAttrs` (Object)\n\nEach **key:value** maps to the equivalent **attribute:value** of the `<body>` element.\n\n```js\n{\n  metaInfo: {\n    bodyAttrs: {\n      bar: 'baz'\n    }\n  }\n}\n```\n\n```html\n<body bar=\"baz\">Foo Bar</body>\n```\n\n#### `base` (Object)\n\nMaps to a newly-created `<base>` element, where object properties map to attributes.\n\n```js\n{\n  metaInfo: {\n    base: { target: '_blank', href: '/' }\n  }\n}\n```\n\n```html\n<base target=\"_blank\" href=\"/\">\n```\n\n#### `meta` ([Object])\n\nEach item in the array maps to a newly-created `<meta>` element, where object properties map to attributes.\n\n```js\n{\n  metaInfo: {\n    meta: [\n      { charset: 'utf-8' },\n      { name: 'viewport', content: 'width=device-width, initial-scale=1' }\n    ]\n  }\n}\n```\n\n```html\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n```\n\nSince v1.5.0, you can now set up meta templates that work similar to the titleTemplate:\n\n```js\n{\n  metaInfo: {\n    meta: [\n      { charset: 'utf-8' },\n      {\n        'vmid': 'og:title',\n        'property': 'og:title',\n        'content': 'Test title',\n        'template': chunk => `${chunk} - My page` //or as string template: '%s - My page'\n      }\n    ]\n  }\n}\n```\n\n```html\n<meta charset=\"utf-8\">\n<meta name=\"og:title\" property=\"og:title\" content=\"Test title - My page\">\n```\n\n\n#### `link` ([Object])\n\nEach item in the array maps to a newly-created `<link>` element, where object properties map to attributes.\n\n```js\n{\n  metaInfo: {\n    link: [\n      { rel: 'stylesheet', href: '/css/index.css' },\n      { rel: 'favicon', href: 'favicon.ico' }\n    ]\n  }\n}\n```\n\n```html\n<link rel=\"stylesheet\" href=\"/css/index.css\">\n<link rel=\"favicon\" href=\"favicon.ico\">\n```\n\n#### `style` ([Object])\n\nEach item in the array maps to a newly-created `<style>` element, where object properties map to attributes.\n\n```js\n{\n  metaInfo: {\n    style: [\n      { cssText: '.foo { color: red }', type: 'text/css' }\n    ]\n  }\n}\n```\n\n```html\n<style type=\"text/css\">.foo { color: red }</style>\n```\n\n#### `script` ([Object])\n\nEach item in the array maps to a newly-created `<script>` element, where object properties map to attributes.\n\n```js\n{\n  metaInfo: {\n    script: [\n      { innerHTML: '{ \"@context\": \"http://schema.org\" }', type: 'application/ld+json' }\n    ]\n  }\n}\n```\n\n```html\n<script type=\"application/ld+json\">{ \"@context\": \"http://schema.org\" }</script>\n```\n\nIf your browser doesn't support `defer` or any other reason, you want to put `<script>` before `</body>`, use `body`.\n\n```js\n{\n  metaInfo: {\n    script: [\n      { innerHTML: 'console.log(\"I am in body\");', type: 'text/javascript', body: true }\n    ]\n  }\n}\n```\n\n#### `noscript` ([Object])\n\nEach item in the array maps to a newly-created `<noscript>` element, where object properties map to attributes.\n\n```js\n{\n  metaInfo: {\n    noscript: [\n      { innerHTML: 'This website requires JavaScript.' }\n    ]\n  }\n}\n```\n\n```html\n<noscript>This website requires JavaScript.</noscript>\n```\n\n#### `__dangerouslyDisableSanitizers` ([String])\n\nBy default, `vue-meta` sanitizes HTML entities in _every_ property. You can disable this behaviour on a per-property basis using `__dangerouslyDisableSantizers`. Just pass it a list of properties you want sanitization to be disabled on:\n\n```js\n{\n  metaInfo: {\n    title: '<I will be sanitized>',\n    meta: [{ vmid: 'description', name: 'description', content: '& I will not be <sanitized>'}],\n    __dangerouslyDisableSanitizers: ['meta']\n  }\n}\n```\n\n```html\n<title>&lt;I will be sanitized&gt;</title>\n<meta vmid=\"description\" name=\"description\" content=\"& I will not be <sanitized>\">\n```\n\n:warning: **Using this option is not recommended unless you know exactly what you are doing.** By disabling sanitization, you are opening potential vectors for attacks such as SQL injection & Cross-Site Scripting (XSS). Be very careful to not compromise your application.\n\n#### `__dangerouslyDisableSanitizersByTagID` ({[String]})\n\nProvides same functionality as `__dangerouslyDisableSanitizers` but you can specify which property for which `tagIDKeyName`'s sanitization should be disabled. It expects an object with the vmid's as key and an array with property names value:\n\n```js\n{\n  metaInfo: {\n    title: '<I will be sanitized>',\n    meta: [{ vmid: 'description', name: 'still-&-sanitized', content: '& I will not be <sanitized>'}],\n    __dangerouslyDisableSanitizersByTagID: { description: ['content'] }\n  }\n}\n```\n\n```html\n<title>&lt;I will be sanitized&gt;</title>\n<meta vmid=\"description\" name=\"still-&amp;-sanitized\" content=\"& I will not be <sanitized>\">\n```\n\n:warning: **Using this option is not recommended unless you know exactly what you are doing.** By disabling sanitization, you are opening potential vectors for attacks such as SQL injection & Cross-Site Scripting (XSS). Be very careful to not compromise your application.\n\n#### `changed` (Function)\n\nWill be called when the client `metaInfo` updates/changes. Receives the following parameters:\n- `newInfo` (Object) - The new state of the `metaInfo` object.\n- `addedTags` ([HTMLElement]) - a list of elements that were added.\n- `removedTags` ([HTMLElement]) - a list of elements that were removed.\n\n`this` context is the component instance `changed` is defined on.\n\n```js\n{\n  metaInfo: {\n    changed (newInfo, addedTags, removedTags) {\n      console.log('Meta info was updated!')\n    }\n  }\n}\n```\n\n### How `metaInfo` is Resolved\n\nYou can define a `metaInfo` property on any component in the tree. Child components that have `metaInfo` will recursively merge their `metaInfo` into the parent context, overwriting any duplicate properties. To better illustrate, consider this component heirarchy:\n\n```html\n<parent>\n  <child></child>\n</parent>\n```\n\nIf both `<parent>` _and_ `<child>` define a `title` property inside `metaInfo`, then the `title` that gets rendered will resolve to the `title` defined inside `<child>`.\n\n#### Lists of Tags\n\nWhen specifying an array in `metaInfo`, like in the below examples, the default behaviour is to simply concatenate the lists.\n\n**Input:**\n```js\n// parent component\n{\n  metaInfo: {\n    meta: [\n      { charset: 'utf-8' },\n      { name: 'description', content: 'foo' }\n    ]\n  }\n}\n// child component\n{\n  metaInfo: {\n    meta: [\n      { name: 'description', content: 'bar' }\n    ]\n  }\n}\n```\n\n**Output:**\n```html\n<meta charset=\"utf-8\">\n<meta name=\"description\" content=\"foo\">\n<meta name=\"description\" content=\"bar\">\n```\n\nThis is not what we want, since the meta `description` needs to be unique for every page. If you want to change this behaviour such that `description` is instead replaced, then give it a `vmid`:\n\n**Input:**\n```js\n// parent component\n{\n  metaInfo: {\n    meta: [\n      { charset: 'utf-8' },\n      { vmid: 'description', name: 'description', content: 'foo' }\n    ]\n  }\n}\n// child component\n{\n  metaInfo: {\n    meta: [\n      { vmid: 'description', name: 'description', content: 'bar' }\n    ]\n  }\n}\n```\n\n**Output:**\n```html\n<meta charset=\"utf-8\">\n<meta vmid=\"description\" name=\"description\" content=\"bar\">\n```\n\nWhile solutions like `react-helmet` manage the occurrence order and merge behaviour for you automatically, it involves a lot more code and is therefore prone to failure in some edge-cases, whereas this method is _almost_ bulletproof because of its versatility; _at the expense of one tradeoff:_ these `vmid` properties will be rendered out in the final markup (`vue-meta` uses these client-side to prevent duplicating or overriding markup). If you are serving your content GZIP'ped, then the slight increase in HTTP payload size is negligible.\n\n# Performance\n\nOn the client, `vue-meta` batches DOM updates using [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame). It needs to do this because it registers a Vue mixin that subscribes to the [`beforeMount`](https://vuejs.org/api/#beforeMount) lifecycle hook on all components in order to be notified that renders have occurred and data is ready. If `vue-meta` did not batch updates, the DOM meta info would be re-calculated and re-updated for every component on the page in quick-succession.\n\nThanks to batch updating, the update will only occurr once - even if the correct meta info has already been compiled by the server. If you don't want this behaviour, see below.\n\n### How to prevent the update on the initial page render\n\nAdd the `data-vue-meta-server-rendered` attribute to the `<html>` tag on the server-side:\n\n```html\n<html data-vue-meta-server-rendered>\n...\n```\n\n`vue-meta` will check for this attribute whenever it attempts to update the DOM - if it exists, `vue-meta` will just remove it and perform no updates. If it does not exist, `vue-meta` will perform updates as usual.\n\n> **Note:** While this may seem verbose, it _is_ intentional. Having `vue-meta` handle this for you automatically would limit interoperability with other server-side programming languages. If you use PHP to power your server, for example, you might also have meta info handled on the server already and want to prevent this extraneous update.\n\n# FAQ\n\nHere are some answers to some frequently asked questions.\n\n## How do I use component props and/or component data in `metaInfo`?\n\nEasy. Instead of defining `metaInfo` as an object, define it as a function and access `this` as usual:\n\n**Post.vue:**\n```html\n<template>\n  <div>\n    <h1>{{{ title }}}</h1>\n  </div>\n</template>\n\n<script>\n  export default {\n    name: 'post',\n    props: ['title'],\n    data () {\n      return {\n        description: 'A blog post about some stuff'\n      }\n    },\n    metaInfo () {\n      return {\n        title: this.title,\n        meta: [\n          { vmid: 'description', name: 'description', content: this.description }\n        ]\n      }\n    }\n  }\n</script>\n```\n\n**PostContainer.vue:**\n```html\n<template>\n  <div>\n    <post :title=\"title\"></post>\n  </div>\n</template>\n\n<script>\n  import Post from './Post.vue'\n\n  export default {\n    name: 'post-container',\n    components: { Post },\n    data () {\n      return {\n        title: 'Example blog post'\n      }\n    }\n  }\n</script>\n```\n\n## How do I populate `metaInfo` from the result of an asynchronous action?\n\n`vue-meta` will do this for you automatically when your component state changes.\n\nJust make sure that you're using the function form of `metaInfo`:\n\n```js\n{\n  data () {\n    return {\n      title: 'Foo Bar Baz'\n    }\n  },\n  metaInfo () {\n    return {\n      title: this.title\n    }\n  }\n}\n```\n\nCheck out the [vuex-async](https://github.com/declandewet/vue-meta/tree/master/examples/vuex-async) example for a far more detailed demonstration if you have doubts.\n\nCredit & Thanks for this feature goes to [SÃ©bastien Chopin](https://github.com/Atinux).\n\n## Why doesn't `vue-meta` support `jsnext:main`?\n\nOriginally, it did - however, it caused [problems](https://github.com/declandewet/vue-meta/issues/25). Essentially, Vue [does not support](https://github.com/vuejs/vue/issues/2880) `jsnext:main`, and does not introspect for the `default` property that is transpiled from the ES2015 source, thus breaking module resolution.\n\nGiven that `jsnext:main` is a non-standard property that won't stick around for long, and `vue-meta` is bundled into one file with no dynamic module internals as well as the fact that if you're using `vue-meta`, you're 99.9% likely to not be using it conditionally - the decision has been made to drop support for it entirely.\n\nIf this were not the case, you would have to instruct Babel to convert `default` imports to the proper commonjs module syntax via a plugin, which is not ideal since many users in the Vue landscape write their code in TypeScript, not Babel.\n\n# Examples\n\nTo run the examples; clone this repository & run `npm install` in the root directory, and then run `npm run dev`. Head to http://localhost:8080.\n\n# TypeScript Support\n\nIf you have problems with types using vue-meta, then you're most probably using vue-class-component.\nIn any troublesome situation, just add the following ambient declaration to your types:\n\n```js\nimport { MetaInfo } from 'vue-meta';\n\ndeclare module \"vue/types/vue\" {\n  interface Vue {\n    metaInfo?: MetaInfo | (() => MetaInfo)\n  }\n}\n```\n",
    "licenseText": "MIT License\n\nCopyright (c) 2016 Declan de Wet\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/vue-meta/-/vue-meta-1.5.0.tgz#02a9f166a1e87763a87bfd47431122ed575bcdde",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/vue-meta/-/vue-meta-1.5.0.tgz",
    "hash": "02a9f166a1e87763a87bfd47431122ed575bcdde",
    "registry": "npm"
  },
  "registry": "npm",
  "hash": "02a9f166a1e87763a87bfd47431122ed575bcdde"
}